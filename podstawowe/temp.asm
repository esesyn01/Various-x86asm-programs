.686
.model flat
extern __write : PROC
extern __read : PROC
extern _ExitProcess@4 : PROC
public _main
.data
znaki db 12 dup (?)
cnt dd ?
obszar db 12 dup (?)
dziesiec dd 10 ; mno¿nik
dwana dd 12
dekoder db '0123456789ABCDEF'
mnoz dd ?
przec db ','
minu db '-'
zmienna dd 45
.code
wyswietl_EAX PROC
pusha
mov esi, 10 ; indeks w tablicy 'znaki'
mov ebx, 10 ; dzielnik równy 10
konwersja:
mov edx, 0 ; zerowanie starszej czêœci dzielnej
div ebx ; dzielenie przez 10, reszta w EDX,
; iloraz w EAX
add dl, 30H ; zamiana reszty z dzielenia na kod
; ASCII
mov znaki [esi], dl; zapisanie cyfry w kodzie ASCII
dec esi ; zmniejszenie indeksu
cmp eax, 0 ; sprawdzenie czy iloraz = 0
jne konwersja ; skok, gdy iloraz niezerowy
; wype³nienie pozosta³ych bajtów spacjami i wpisanie
; znaków nowego wiersza
wypeln:
or esi, esi
jz wyswietl ; skok, gdy ESI = 0
mov byte PTR znaki [esi], 0 ; kod spacji
dec esi ; zmniejszenie indeksu
jmp wypeln
wyswietl:
; wyœwietlenie cyfr na ekranie
mov byte PTR znaki[11], 10
push dword PTR 12 ; liczba wyœwietlanych znaków
push dword PTR OFFSET znaki ; adres wyœw. obszaru
push dword PTR 1; numer urz¹dzenia (ekran ma numer 1)
call __write ; wyœwietlenie liczby na ekranie
add esp, 12 ; usuniêcie parametrów ze stosu
popa
ret
wyswietl_EAX ENDP
wyswietl_EAX2 PROC
pusha
mov esi, 10 ; indeks w tablicy 'znaki'
mov ebx, 10 ; dzielnik równy 10
konwersja:
mov edx, 0 ; zerowanie starszej czêœci dzielnej
div ebx ; dzielenie przez 10, reszta w EDX,
; iloraz w EAX
add dl, 30H ; zamiana reszty z dzielenia na kod
; ASCII
mov znaki [esi], dl; zapisanie cyfry w kodzie ASCII
dec esi ; zmniejszenie indeksu
cmp eax, 0 ; sprawdzenie czy iloraz = 0
jne konwersja ; skok, gdy iloraz niezerowy
; wype³nienie pozosta³ych bajtów spacjami i wpisanie
; znaków nowego wiersza
wypeln:
or esi, esi
jz wyswietl ; skok, gdy ESI = 0
cmp esi, 7
ja zeroo
mov byte PTR znaki [esi], 0 ; kod spacji
jmp lecymy
zeroo:
mov byte PTR znaki [esi],30h
lecymy:
dec esi ; zmniejszenie indeksu
jmp wypeln
wyswietl:
; wyœwietlenie cyfr na ekranie
push dword PTR 12 ; liczba wyœwietlanych znaków
push dword PTR OFFSET znaki ; adres wyœw. obszaru
push dword PTR 1; numer urz¹dzenia (ekran ma numer 1)
call __write ; wyœwietlenie liczby na ekranie
add esp, 12 ; usuniêcie parametrów ze stosu
popa
ret
wyswietl_EAX2 ENDP
wczytaj_EAX PROC
push ebx
push ecx
; max iloœæ znaków wczytywanej liczby
push dword PTR 12
push dword PTR OFFSET obszar ; adres obszaru pamiêci
push dword PTR 0; numer urz¹dzenia (0 dla klawiatury)
call __read ; odczytywanie znaków z klawiatury
; (dwa znaki podkreœlenia przed read)
add esp, 12 ; usuniêcie parametrów ze stosu
; bie¿¹ca wartoœæ przekszta³canej liczby przechowywana jest
; w rejestrze EAX; przyjmujemy 0 jako wartoœæ pocz¹tkow¹
mov eax, 0
mov ebx, OFFSET obszar ; adres obszaru ze znakami
pobieraj_znaki:
mov cl, [ebx] ; pobranie kolejnej cyfry w kodzie
; ASCII
inc ebx ; zwiêkszenie indeksu
cmp cl,10 ; sprawdzenie czy naciœniêto Enter
je byl_enter ; skok, gdy naciœniêto Enter
sub cl, 30H ; zamiana kodu ASCII na wartoœæ cyfry
movzx ecx, cl ; przechowanie wartoœci cyfry w
; rejestrze ECX
; mno¿enie wczeœniej obliczonej wartoœci razy 10
mul dword PTR dziesiec
add eax, ecx ; dodanie ostatnio odczytanej cyfry
jmp pobieraj_znaki ; skok na pocz¹tek pêtli
byl_enter:
; wartoœæ binarna wprowadzonej liczby znajduje siê teraz w
pop ecx
pop ebx
ret
wczytaj_EAX ENDP
wyswietl_EAX_hex PROC
pusha
sub esp, 12
mov edi, esp ; adres zarezerwowanego obszaru
mov ecx, 8 ; liczba obiegów pêtli konwersji
mov esi, 1 ; indeks pocz¹tkowy u¿ywany przy
ptl3hex:
rol eax, 4
; wyodrêbnienie 4 najm³odszych bitów i odczytanie z tablicy
; 'dekoder' odpowiadaj¹cej im cyfry w zapisie szesnastkowym
mov ebx, eax ; kopiowanie EAX do EBX
and ebx, 0000000FH ; zerowanie bitów 31 - 4 rej.EBX
mov dl, dekoder[ebx] ; pobranie cyfry z tablicy
; przes³anie cyfry do obszaru roboczego
mov [edi][esi], dl
inc esi ;inkrementacja modyfikatora
loop ptl3hex ; sterowanie pêtl¹

; wpisanie znaku nowego wiersza przed i po cyfrach
mov byte PTR [edi][0], 10
mov byte PTR [edi][9], 10
mov ecx,7
mov ebx,1
spacje:
mov dl,[edi][ebx]
cmp dl, 30h
je spacje1
mov ecx,1
jmp dalej
spacje1:
mov dl, 20h
mov [edi][ebx],dl
dalej:
inc ebx
dec ecx
jnz spacje
; wyœwietlenie przygotowanych cyfr
push 10 ; 8 cyfr + 2 znaki nowego wiersza
push edi ; adres obszaru roboczego
push 1 ; nr urz¹dzenia (tu: ekran)
call __write ; wyœwietlenie
; usuniêcie ze stosu 24 bajtów, w tym 12 bajtów zapisanych
; przez 3 rozkazy push przed rozkazem call
; i 12 bajtów zarezerwowanych na pocz¹tku podprogramu
add esp, 24
popa ; odtworzenie rejestrów
ret ; powrót z podprogramu
wyswietl_EAX_hex ENDP
wczytaj_do_EAX_hex PROC
; wczytywanie liczby szesnastkowej z klawiatury – liczba po
; konwersji na postaæ binarn¹ zostaje wpisana do rejestru EAX
; po wprowadzeniu ostatniej cyfry nale¿y nacisn¹æ klawisz
; Enter
push ebx
push ecx
push edx
push esi
push edi
push ebp
; rezerwacja 12 bajtów na stosie przeznaczonych na tymczasowe
; przechowanie cyfr szesnastkowych wyœwietlanej liczby
sub esp, 12 ; rezerwacja poprzez zmniejszenie ESP
mov esi, esp ; adres zarezerwowanego obszaru pamiêci
push dword PTR 10 ; max iloœæ znaków wczytyw. liczby
push esi ; adres obszaru pamiêci
push dword PTR 0; numer urz¹dzenia (0 dla klawiatury)
call __read ; odczytywanie znaków z klawiatury
; (dwa znaki podkreœlenia przed read)
add esp, 12 ; usuniêcie parametrów ze stosu
mov eax, 0 ; dotychczas uzyskany wynik
pocz_konw:
mov dl, [esi] ; pobranie kolejnego bajtu
inc esi ; inkrementacja indeksu
cmp dl, 10 ; sprawdzenie czy naciœniêto Enter
je gotowe ; skok do koñca podprogramu
; sprawdzenie czy wprowadzony znak jest cyfr¹ 0, 1, 2 , ..., 9
cmp dl, '0'
jb pocz_konw ; inny znak jest ignorowany
cmp dl, '9'
ja sprawdzaj_dalej
sub dl, '0' ; zamiana kodu ASCII na wartoœæ cyfry
dopisz:
shl eax, 4 ; przesuniêcie logiczne w lewo o 4 bity
or al, dl ; dopisanie utworzonego kodu 4-bitowego
 ; na 4 ostatnie bity rejestru EAX
jmp pocz_konw ; skok na pocz¹tek pêtli konwersji
; sprawdzenie czy wprowadzony znak jest cyfr¹ A, B, ..., F
sprawdzaj_dalej:
cmp dl, 'A'
jb pocz_konw ; inny znak jest ignorowany
cmp dl, 'F'
ja sprawdzaj_dalej2
sub dl, 'A' - 10 ; wyznaczenie kodu binarnego
jmp dopisz
; sprawdzenie czy wprowadzony znak jest cyfr¹ a, b, ..., f
sprawdzaj_dalej2:
cmp dl, 'a'
jb pocz_konw ; inny znak jest ignorowany
cmp dl, 'f'
ja pocz_konw ; inny znak jest ignorowany
sub dl, 'a' - 10
jmp dopisz
gotowe:
; zwolnienie zarezerwowanego obszaru pamiêci
add esp, 12
pop ebp
pop edi
pop esi
pop edx
pop ecx
pop ebx
ret
wczytaj_do_EAX_hex ENDP
wczytaj_dwu PROC
push ebx
push ecx
push edx
push esi
push edi
push ebp
push dword PTR 12
push dword PTR OFFSET obszar ; adres obszaru pamiêci
push dword PTR 0; numer urz¹dzenia (0 dla klawiatury)
call __read ; odczytywanie znaków z klawiatury
; (dwa znaki podkreœlenia przed read)
add esp, 12 ; usuniêcie parametrów ze stosu
; bie¿¹ca wartoœæ przekszta³canej liczby przechowywana jest
; w rejestrze EAX; przyjmujemy 0 jako wartoœæ pocz¹tkow¹
mov eax, 0
mov ebx, OFFSET obszar ; adres obszaru ze znakami
ptl:
mov cl,[ebx]
cmp cl,10
je bylenter
cmp cl,3ah
jb cyfra
sub cl, 55
jmp dalej
cyfra:
sub cl, 30h
dalej:
movzx ecx,cl
inc ebx
mul dwana
add eax,ecx
jmp ptl
bylenter:
pop ebp
pop edi
pop esi
pop edx
pop ecx
pop ebx
ret
wczytaj_dwu ENDP
wczytaj_EAXn PROC
push ecx
; max iloœæ znaków wczytywanej liczby
; (dwa znaki podkreœlenia przed read)
; bie¿¹ca wartoœæ przekszta³canej liczby przechowywana jest
; w rejestrze EAX; przyjmujemy 0 jako wartoœæ pocz¹tkow¹
mov eax,[ebx]
pop ecx
ret
wczytaj_EAXn ENDP
przecinek PROC
pusha
push 1
push OFFSET przec
push 1
call __write
add esp,12
popa
ret
przecinek ENDP
minuss PROC
pusha
push 1
push OFFSET minu
push 1
call __write
add esp,12
popa
ret
minuss ENDP
ciag PROC
pusha
lea ebx,zmienna
mov ecx,[ebx]
mov eax,1
mov ebx,0
ptl:
cmp eax,0
jle ujemna
call wyswietl_EAX
inc ebx
dec ecx
cmp ecx,0
je koniec
sub eax,ebx
jmp dalej
ujemna:
neg eax
call minuss
call wyswietl_EAX
neg eax
inc ebx
cmp ecx,0
je koniec
add eax,ebx
jmp dalej
dalej:
jmp ptl
koniec:
popa
ret
ciag ENDP
_main PROC
call wczytaj_dwu
mov ebx,eax
call wczytaj_dwu
xchg eax,ebx
mov edx,0
div ebx
call wyswietl_EAX
call przecinek
mov eax,edx
mov mnoz, 1000
mul mnoz
mov edx,0
div ebx
call wyswietl_EAX2
;mov eax,1
;mov ebx,1
;mov ecx,15
;ptl:
;call wyswietl_EAX
;sub eax,ebx
;inc ebx
;cmp eax, 0
;jne dalej
;call wyswietl_EAX
;jmp dalej2
;dalej:
;neg eax ; tu jeszcze wyswietlic minus
;call wyswietl_EAX
;neg eax
;dalej2:
;add eax,ebx
;inc ebx
;dec ecx
;jnz ptl
;call ciag
push 0
call _ExitProcess@4
_main ENDP
END